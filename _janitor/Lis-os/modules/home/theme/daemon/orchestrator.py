import sys
import json
import time
import signal
import os
from pathlib import Path

# Try to import tomllib (Python 3.11+), fallback to tomli
try:
    import tomllib
except ImportError:
    import tomli as tomllib


# PATHS
HOME = Path.home()
CONFIG_DIR = HOME / ".config" / "lis-os" / "config.d"
# Dev path: The actual source of the config in the repo
DEV_SOURCE_DIR = HOME / "Lis-os" / "modules" / "home" / "desktop" / "astal"

CACHE_DIR = HOME / ".cache" / "theme-engine"
PALETTE_FILE = CACHE_DIR / "palette.json"
SIGNAL_FILE = CACHE_DIR / "signal"

# OUTPUTS
ASTAL_CONFIG = HOME / ".run" / "lis-os" / "config.json"
GTK_CSS = HOME / ".cache" / "wal" / "ags-colors.css"

# Ensure dirs exist
ASTAL_CONFIG.parent.mkdir(parents=True, exist_ok=True)
GTK_CSS.parent.mkdir(parents=True, exist_ok=True)


def load_palette():
    """Load the colors generated by the bash engine."""
    if not PALETTE_FILE.exists():
        return {}
    try:
        with open(PALETTE_FILE, "r") as f:
            data = json.load(f)
            return data.get("colors", {})
    except Exception as e:
        print(f"Error loading palette: {e}", file=sys.stderr, flush=True)
        return {}


def generate_css(palette):
    """Generate valid GTK3 CSS from the palette."""
    css = "/* Generated by lis-daemon */\n"
    
    # 1. Standard Colors (Native GTK3 Syntax)
    for key, hex_val in palette.items():
        css += f"@define-color {key} {hex_val};\n"

    # 2. Write file
    with open(GTK_CSS, "w") as f:
        f.write(css)
    # print(f"Generated CSS at {GTK_CSS}", flush=True)


def merge_configs():
    """Merge all TOML files in config.d into a single JSON."""
    final_config = {}

    # Check if directory exists
    if not CONFIG_DIR.exists():
        print(f"Config dir {CONFIG_DIR} does not exist. Skipping merge.", flush=True)
        # Write empty config so Astal doesn't crash
        with open(ASTAL_CONFIG, "w") as f:
            json.dump({}, f)
        return

    # Simple alphabetical merge strategy
    toml_files = sorted(CONFIG_DIR.glob("*.toml"))
    if not toml_files:
        # print("No config files found.", flush=True)
        pass

    for path in toml_files:
        try:
            with open(path, "rb") as f:
                data = tomllib.load(f)
                final_config.update(data)
        except Exception as e:
            print(f"Failed to parse {path.name}: {e}", file=sys.stderr, flush=True)

    # DEBUG: Print keys
    print(f"Merged Keys: {list(final_config.keys())}", flush=True)

    # Write JSON for Astal
    with open(ASTAL_CONFIG, "w") as f:
        json.dump(final_config, f, indent=2)
    print(f"Generated Config at {ASTAL_CONFIG}", flush=True)


def update_all():
    print(f"[{time.strftime('%H:%M:%S')}] Detected change. Updating...", flush=True)
    palette = load_palette()
    generate_css(palette)
    merge_configs()
    SIGNAL_FILE.touch()


def get_combined_mtime(paths):
    """Get the max mtime of all files in the given paths (recursive)."""
    max_mtime = 0
    for path in paths:
        if not path.exists():
            continue
        if path.is_file():
            max_mtime = max(max_mtime, path.stat().st_mtime)
        elif path.is_dir():
            for root, _, files in os.walk(path):
                for f in files:
                    if f.endswith(".toml"):  # Only watch toml for efficiency
                        full_path = Path(root) / f
                        max_mtime = max(max_mtime, full_path.stat().st_mtime)
    return max_mtime


def main():
    print("Starting Lis-OS Orchestrator (Polling Mode)...", flush=True)
    
    # Define what to watch
    watch_targets = [CONFIG_DIR]
    
    # Watch the specific source file for reliability
    dev_config_file = DEV_SOURCE_DIR / "default.toml"
    if dev_config_file.exists():
        watch_targets.append(dev_config_file)
        print(f"Watching Dev Source File: {dev_config_file}", flush=True)

    # Initial Run
    update_all()
    last_mtime = get_combined_mtime(watch_targets)

    # Polling Loop (1Hz)
    while True:
        try:
            current_mtime = get_combined_mtime(watch_targets)
            if current_mtime > last_mtime:
                last_mtime = current_mtime
                update_all()
            time.sleep(1)
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"Polling error: {e}", file=sys.stderr, flush=True)
            time.sleep(5)


if __name__ == "__main__":
    signal.signal(signal.SIGINT, lambda s, f: sys.exit(0))
    main()
